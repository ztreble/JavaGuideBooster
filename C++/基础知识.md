1. private, public, protected 访问标号的访问范围
private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。
protected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。
但不能被该类的对象访问。
public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

2. 类被继承后方法属性变化
private 属性不能够被继承。
使用private继承， 父类的protected和public属性在子类中变为private；
使用protected继承，父类的protected和public属性在子类中变为protected；
使用public继承， 父类的protected和public属性不发生改变;

<<<<<<< HEAD
3. 说一下C++初始化顺序？

4. 什么时候会产生默认构造函数？
没有定义任何构造函数的时候。

5. 什么叫引用？和指针有什么区别？
应用是变量的一个别名，传递的也是变量的地址。
因为引用是变量的地址，所以必须被初始化。
引用只能有一级。
sizeof引用得到的是引用指向的变量的大小。

6. C++中类成员的默认访问级别是什么？
private

7. 比较一下指针和引用使用的场景？
引用可以防止传递nullptr

8. std::move的使用场景是什么？
```c
我们有一个左值，希望像右值一样处理它
Person p{"Jack"}; // 创建一个临时变量，如果一个move；多半情况下编译器会直接创建在Person里
std::string name{"John"};
Person p1{name}; // 这种情况跟用const引用一样，都是一次copy
Person p2{std::move(name)}; // 因为被转化成了右值，name会被直接移动到p2里，省掉一次copy
```

9. 请解释一下COW和SSO
1.COW
思想是只有当修改string的时候再为这个修改操作重新生成一个拷贝，如果只是复制，那么就是共享这个数据。COW的实现机制是用一个引用计数，初始值是1，每次赋值的时候都会加1。当修改的时候，如果count > 1， 则会重新申请空间并复制，并且count--（因为正在修改的这个之前肯定是引用了这个数据），然后如果count = 0， 则释放原来内存。
需要注意的是，string会把[]跟at()操作认定为修改操作，因为很难定义到底是不是修改，所以一律当成了修改。比如以下的代码，string a = "hi", string b = a; b[0] = 'i';
则a= "hi", b="ii".
2.SSO small string optimization
因为COW的弊端（除了上面提到的，还有其他的，比如多线程问题），新版本的编译器大多放弃了COW，而使用了SSO。SSO思想是立刻复制，同时有一个优化就是当字符串较短时，直接将其数据放到栈中，而不是在堆中动态申请内存，避免了申请空间的开销。
回到开头的例子，就不难理解为什么VS会输出false, false, false了，因为每次都是深拷贝。

10. C++函数如何返回多个值？
使用tuple或者pair<bool,Out>
或者optional<Out>

- 如何限制构造函数的隐式拷贝？
使用explicit

- 说一下回调函数和仿函数

仿函数的优点：
1、拥有状态
仿函数的能力超越了operator(),仿函数可以拥有成员函数和成员变量，这就意味着仿函数可以同时拥有状态不同的两个实体。一般函数则达不到这样的能力。
2、拥有自己的型别
我们可以将仿函数的型别当做template参数来传递，从而指定某种行为模式。容器型别也会因为仿函数的不同而不同。
3、仿函数速度更快
就template概念而言，由于很多细节在编译期就已经确定，传入一个仿函数，就可能活动更好的性能。

- 如何使用继承预算符？
使用public，用内含替代其它作用符

- 析构函数何时应该声明为virtual？
当有其它虚函数的时候
=======
3. 说一下C++初始化顺序？
>>>>>>> master
